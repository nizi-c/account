import { TransactionRepository, CategoryRepository, AchievementRepository, BudgetRepository } from '../repositories';
import { ExportData, Transaction, MoodType, TransactionType, Budget } from '../models';
import { DateUtils } from '../utils/DateUtils';
import { fileIo } from '@kit.CoreFileKit';
import { common } from '@kit.AbilityKit';

/**
 * Export Service
 * æ•°æ®å¯¼å‡ºä¸šåŠ¡é€»è¾‘å±‚
 */
export class ExportService {
  private transactionRepo: TransactionRepository;
  private categoryRepo: CategoryRepository;
  private achievementRepo: AchievementRepository;
  private budgetRepo: BudgetRepository;
  private context?: common.UIAbilityContext;

  constructor(
    transactionRepo: TransactionRepository,
    categoryRepo: CategoryRepository,
    achievementRepo: AchievementRepository,
    budgetRepo: BudgetRepository,
    context?: common.UIAbilityContext
  ) {
    this.transactionRepo = transactionRepo;
    this.categoryRepo = categoryRepo;
    this.achievementRepo = achievementRepo;
    this.budgetRepo = budgetRepo;
    this.context = context;
  }

  /**
   * Export to CSV format with optional date range filtering
   * å¯¼å‡ºä¸ºCSVæ ¼å¼ï¼ˆæ”¯æŒæ—¥æœŸèŒƒå›´è¿‡æ»¤ï¼‰
   * @param startDate - Optional start date timestamp
   * @param endDate - Optional end date timestamp
   * @returns CSV content as string
   */
  async exportToCSV(startDate?: number, endDate?: number): Promise<string> {
    try {
      // Get transactions with optional date filtering
      let transactions: Transaction[];
      
      if (startDate !== undefined && endDate !== undefined) {
        transactions = await this.transactionRepo.getByDateRange(startDate, endDate);
      } else {
        transactions = await this.transactionRepo.getAll();
      }

      // Generate CSV content
      const csvContent = this.generateCSVContent(transactions);
      
      return csvContent;
    } catch (error) {
      console.error('Error exporting to CSV:', error);
      throw new Error(`CSVå¯¼å‡ºå¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
    }
  }

  /**
   * Export to JSON format with optional date range filtering
   * å¯¼å‡ºä¸ºJSONæ ¼å¼ï¼ˆæ”¯æŒæ—¥æœŸèŒƒå›´è¿‡æ»¤ï¼‰
   * @param startDate - Optional start date timestamp
   * @param endDate - Optional end date timestamp
   * @returns ExportData object
   */
  async exportToJSON(startDate?: number, endDate?: number): Promise<ExportData> {
    try {
      // Get transactions with optional date filtering
      let transactions: Transaction[];
      
      if (startDate !== undefined && endDate !== undefined) {
        transactions = await this.transactionRepo.getByDateRange(startDate, endDate);
      } else {
        transactions = await this.transactionRepo.getAll();
      }

      // Get categories and achievements (always include all)
      const categories = await this.categoryRepo.getAll();
      const achievements = await this.achievementRepo.getAll();
      
      // Get budgets (optional, may not exist)
      let budgets: Budget[] = [];
      try {
        budgets = await this.budgetRepo.getAll();
      } catch (error) {
        console.warn('Failed to get budgets for export:', error);
      }

      // Create export data object
      const exportData: ExportData = {
        version: '1.0.0',
        exportDate: Date.now(),
        transactions: transactions,
        categories: categories,
        achievements: achievements,
        budgets: budgets.length > 0 ? budgets : undefined
      };

      return exportData;
    } catch (error) {
      console.error('Error exporting to JSON:', error);
      throw new Error(`JSONå¯¼å‡ºå¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
    }
  }

  /**
   * Generate CSV content from transactions
   * ç”ŸæˆCSVå†…å®¹ï¼ˆåŒ…å«è¡¨å¤´ï¼šæ—¥æœŸã€ç±»å‹ã€åˆ†ç±»ã€é‡‘é¢ã€ç”¨é€”ã€æƒ…ç»ªï¼‰
   * @param transactions - Array of transactions
   * @returns CSV formatted string
   */
  generateCSVContent(transactions: Transaction[]): string {
    // CSV header
    const header = 'æ—¥æœŸ,ç±»å‹,åˆ†ç±»,é‡‘é¢,ç”¨é€”,æƒ…ç»ª\n';
    
    // Convert transactions to CSV rows
    const rows = transactions.map(transaction => {
      const date = DateUtils.formatDate(transaction.date, 'YYYY-MM-DD');
      const type = transaction.type === TransactionType.INCOME ? 'æ”¶å…¥' : 'æ”¯å‡º';
      const category = this.escapeCsvField(transaction.category);
      const amount = transaction.amount.toFixed(2);
      const description = this.escapeCsvField(transaction.description);
      const mood = this.getMoodLabel(transaction.mood);
      
      return `${date},${type},${category},${amount},${description},${mood}`;
    });

    return header + rows.join('\n');
  }

  /**
   * Generate full backup including all data
   * ç”Ÿæˆå®Œæ•´å¤‡ä»½ï¼ˆåŒ…å«äº¤æ˜“ã€åˆ†ç±»ã€æˆå°±ã€é¢„ç®—ï¼‰
   * @returns ExportData object with all data
   */
  async generateFullBackup(): Promise<ExportData> {
    try {
      // Get all data
      const transactions = await this.transactionRepo.getAll();
      const categories = await this.categoryRepo.getAll();
      const achievements = await this.achievementRepo.getAll();
      
      // Get budgets (optional)
      let budgets: Budget[] = [];
      try {
        budgets = await this.budgetRepo.getAll();
      } catch (error) {
        console.warn('Failed to get budgets for backup:', error);
      }

      // Create full backup data
      const backupData: ExportData = {
        version: '1.0.0',
        exportDate: Date.now(),
        transactions: transactions,
        categories: categories,
        achievements: achievements,
        budgets: budgets.length > 0 ? budgets : undefined
      };

      return backupData;
    } catch (error) {
      console.error('Error generating full backup:', error);
      throw new Error(`å®Œæ•´å¤‡ä»½ç”Ÿæˆå¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
    }
  }

  /**
   * Save export file to user accessible directory
   * ä¿å­˜å¯¼å‡ºæ–‡ä»¶åˆ°ç”¨æˆ·å¯è®¿é—®ç›®å½•
   * @param content - File content (string or JSON)
   * @param filename - File name
   * @param format - File format ('csv' or 'json')
   * @returns File path where the file was saved
   */
  async saveExportFile(content: string, filename: string, format: 'csv' | 'json'): Promise<string> {
    try {
      if (!this.context) {
        throw new Error('Contextæœªåˆå§‹åŒ–ï¼Œæ— æ³•ä¿å­˜æ–‡ä»¶');
      }

      // Get files directory (user accessible)
      const filesDir = this.context.filesDir;
      
      // Ensure filename has correct extension
      const extension = format === 'csv' ? '.csv' : '.json';
      const finalFilename = filename.endsWith(extension) ? filename : `${filename}${extension}`;
      
      // Full file path
      const filePath = `${filesDir}/${finalFilename}`;

      // Write file with retry logic
      let retryCount = 0;
      const maxRetries = 3;
      
      while (retryCount < maxRetries) {
        try {
          // Open file for writing (create if not exists, truncate if exists)
          const file = fileIo.openSync(filePath, fileIo.OpenMode.CREATE | fileIo.OpenMode.TRUNC | fileIo.OpenMode.WRITE_ONLY);
          
          // Write content
          fileIo.writeSync(file.fd, content);
          
          // Close file
          fileIo.closeSync(file);
          
          console.info(`File saved successfully: ${filePath}`);
          return filePath;
        } catch (writeError) {
          retryCount++;
          console.error(`Write attempt ${retryCount} failed:`, writeError);
          
          if (retryCount >= maxRetries) {
            throw new Error(`File write failed after ${maxRetries} attempts: ${writeError}`);
          }
          
          // Wait before retry (exponential backoff)
          await this.delay(100 * Math.pow(2, retryCount - 1));
        }
      }

      throw new Error('æ–‡ä»¶ä¿å­˜å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°');
    } catch (error) {
      console.error('Error saving export file:', error);
      throw new Error(`æ–‡ä»¶ä¿å­˜å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
    }
  }

  /**
   * Escape CSV field (handle commas, quotes, newlines)
   * è½¬ä¹‰CSVå­—æ®µ
   * @param field - Field value
   * @returns Escaped field value
   */
  private escapeCsvField(field: string): string {
    if (!field) {
      return '';
    }
    
    // If field contains comma, quote, or newline, wrap in quotes and escape quotes
    if (field.includes(',') || field.includes('"') || field.includes('\n')) {
      return `"${field.replace(/"/g, '""')}"`;
    }
    
    return field;
  }

  /**
   * Get mood label in Chinese
   * è·å–æƒ…ç»ªæ ‡ç­¾ä¸­æ–‡
   * @param mood - Mood type
   * @returns Chinese mood label
   */
  private getMoodLabel(mood?: MoodType): string {
    if (!mood) {
      return '';
    }
    
    switch (mood) {
      case MoodType.SATISFIED:
        return 'æ»¡æ„ğŸ˜Š';
      case MoodType.REGRET:
        return 'åæ‚”ğŸ˜Ÿ';
      case MoodType.SURPRISE:
        return 'æƒŠå–œğŸ‰';
      default:
        return '';
    }
  }

  /**
   * Delay helper for retry logic
   * å»¶è¿Ÿè¾…åŠ©å‡½æ•°ï¼ˆç”¨äºé‡è¯•é€»è¾‘ï¼‰
   * @param ms - Milliseconds to delay
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
